package kdm;

public class BaseTree {
	
	/*
	 * 树的基本概念：
	 * 1、节点、根节点、父节点、子节点、兄弟节点;
	 * 2、一棵树没有任何节点叫做空树;
	 * 3、子树、左子树、右子树;
	 * 4、节点的度（degree）：子树的个数;
	 * 5、树的度：所有节点度中最大的值;
	 * 6、叶子节点（left）：度为0的节点;
	 * 
	 * 节点的深度（depth）：从根节点到当前节点的唯一路径上的节点总数;
	 * 节点的高度：从当前节点到最远节点的路径上的节点总数;
	 * 
	 * */
	
	/**
	 * 二叉树的概念：
	 * 1、每个节点的度最大为2（最多有2个子树）;
	 * 2、左子树和右子树是有顺序的，即使只有一个子树，也分左子树和右子树;
	 * 
	 * 二叉树的性质：
	 * 1、非空二叉树第i层，最多有2^(i-1)个节点（i>=1）;
	 * 2、在高度为h的二叉树上，最多有2^(h) - 1个结点（h>=1）;
	 * 3、对于任何一课非空二叉树，如果叶子节点数为n0,度为2的节点个数为n2,则n0 = n2 + 1;
	 * 证明：
	 * 假设度为1的节点数为n1，则二叉树的节点总数n=n0 + n1 + n2;
	 * ∵ 二叉树的边数T = n1 + 2 * n2（度为1的节点数有1条边， 度为2的节点有2条边），
	 * T = n - 1 （每个子节点都有对应的一条边，除了根节点没有边）
	 * ∴ n1 + 2 * n2 = n - 1 = n0 + n1 + n2 - 1（约分）
	 * ∴ n2 = n0 - 1
	 * ∴ n0 = n2 + 1
	 */
	
	/* 
	 * 满二叉树、真二叉树
	 * 1、真二叉树： 所有节点的度数要不为0，要不为2;
	 * 2、满二叉树：最后一层的节点的度为0，其他层的节点度都为2;
	 * 3、假设满二叉树的高度为h（h>=1），则：
	 * 	第i层的节点数量为2^(i-1),叶子节点数量为2^(h-1);
	 *  总节点数量为n = 2^(h) - 1 = 2^(0) + 2^(1) + 2^(2) + ... + 2^(h - 1)
	 *  h = log2(n+1)
	 * 4、在同样高度的二叉树中，满二叉树的叶子节点数量最多，总节点数最多；
	 * 5、满二叉树一定是真二叉树，真二叉树不一定是满二叉树；  
	 * */
	
	/**
	 * 完全二叉树（Complete Binary Tree）
	 * 1、完全二叉树：对节点从上至下，左至右开始编号；
	 * 2、叶子节点只会出现在最后俩层，最后一层的叶子节点都是靠左对齐；
	 * 3、完全二叉树从根节点到倒数第二层是一颗满二叉树；
	 * 4、满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树；
	 * 性质：
	 * 1、假设完全二叉树的高度为h（h>=1），那么：
	 * 至少有2^(h-1)个节点；
	 * 最多有2^(h) - 1个节点（满二叉树）;
	 * 总节点数量为n，则：
	 * 2^(h-1) <= n < 2^(h) ==> h - 1 <= log2(n) < h;
	 * h = floor（log2(n)）+ 1;
	 * floor是向下取整， ceiling是向上取整;
	 * 
	 * 2、一颗完全二叉树节点数为n， 则其叶子节点n0 = floor（（n + 1）/ 2）
	 */
	
	/*
	 * 二叉树常见的遍历,根据节点访问顺序的不同分为以下几种遍历方式：
	 * 1、前序遍历(PreOrder Traversal)： 根节点、前序遍历左子树、前序遍历右子树
	 * 2、中序遍历(InOrder Traversal)
	 * 3、后序遍历(postOrder Traversal)
	 * 4、层序遍历 (LevelOrder Traversal)
	 */
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

}
